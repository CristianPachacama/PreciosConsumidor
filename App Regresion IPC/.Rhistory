rangos2
rangos3
rangos4
write.csv(rangos3,file = "Analizado/Rango3.csv")
write.csv(rangos4,file = "Analizado/Rango4.csv")
write.csv(rangos3,file = "Analizado/Rango3.csv")
write.csv(rangos4,file = "Analizado/Rango4.csv")
#Grafico de Series --------------------------------------------
library(dygraphs)
graf_series = function(BDDts){
aux = BDDts
dygraph(aux, main = "Grafico Conjunto",group = 'grupoIndices')%>%
dyAxis('y',label='Series')%>%
dyHighlight(highlightSeriesBackgroundAlpha = 0.3)%>%
dyLegend(show= "follow",width = 400)
}
names(IPC) = c("Fecha",items)
IPCaux3 = IPC[,c("Fecha",as.character(rangos3$Abreviatura))]
BDD3 = Tmp %>% #inner_join(Gini) %>%
inner_join(IPCaux3) #%>% inner_join(PIB)
IPCaux4 = IPC[,c("Fecha",as.character(rangos4$Abreviatura))]
BDD4 = Tmp %>% #inner_join(Gini) %>%
inner_join(IPCaux4) #%>%  inner_join(PIB)
BDDts3 = ts(BDD3[,-(1:3)], start = c(2005, 1),frequency = 12)
BDDts4 = ts(BDD4[,-(1:3)], start = c(2005, 1),frequency = 12)
graf_series(BDDts3)
graf_series(BDDts4)
install.packages("mFilter")
# Filtro Hodrick-Prescott  ---------------------------
hpfilter <- function(x,freq=NULL,type=c("lambda","frequency"),drift=FALSE)
{
if(is.null(drift)) drift <- FALSE
xname=deparse(substitute(x))
type=match.arg(type)
if(is.null(type)) type <- "lambda"
if(is.ts(x))
{
tsp.x <- tsp(x)
frq.x <- frequency(x)
if(type=="lambda")
{
if(is.null(freq))
{
if(frq.x==1)
lambda = 6
if(frq.x==4)
lambda = 1600
if(frq.x==12)
lambda = 129600
}
else
lambda = freq
}
}
else
{
if(type=="lambda")
{
if(is.null(freq))
stop("freq is NULL")
else
lambda = freq
}
}
if(type=="frequency")
{
if(is.null(freq))
stop("freq is NULL")
else
lambda = (2*sin(pi/freq))^-4
}
xo = x
x = as.matrix(x)
if(drift)
x = undrift(x)
n = length(x)
imat = diag(n)
Ln = rbind(matrix(0,1,n),diag(1,n-1,n))
Ln = (imat-Ln)%*%(imat-Ln)
Q  = t(Ln[3:n,])
SIGMA.R = t(Q)%*%Q
SIGMA.n = diag(n-2)
g = t(Q)%*%as.matrix(x)
b = solve(SIGMA.n+lambda*SIGMA.R,g)
x.cycle = c(lambda*Q%*%b)
x.trend = x-x.cycle
if(is.ts(xo))
{
tsp.x = tsp(xo)
x.cycle=ts(x.cycle,star=tsp.x[1],frequency=tsp.x[3])
x.trend=ts(x.trend,star=tsp.x[1],frequency=tsp.x[3])
x=ts(x,star=tsp.x[1],frequency=tsp.x[3])
}
A = lambda*Q%*%solve(SIGMA.n+lambda*SIGMA.R)%*%t(Q)
res <- list(cycle=x.cycle,trend=x.trend,fmatrix=A,title="Hodrick-Prescott Filter",
xname=xname,call=as.call(match.call()),
type=type,lambda=lambda,method="hpfilter",x=x)
return(structure(res,class="mFilter"))
}
tsp(BDDts3[,2])
tx = hpfilter(BDDts3[,2])
tx
plot(tx)
plot(tx$x)
plot(BDDts3[,2])
plot(tx$trend)
plot(tx$fmatrix)
plot(tx$trend)
plot(tx$x)
install.packages("quantmod")
library(quantmod)
getSymbols('GDP',src='FRED')
plot(hpfilter(log(GDP),freq = 1600))
install.packages("mFilter")
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#-----------------------         Filtro Hodrick-Prescott        ---------------------------
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
hpfilter <- function(x,freq=NULL,type=c("lambda","frequency"),drift=FALSE)
{
if(is.null(drift)) drift <- FALSE
xname=deparse(substitute(x))
type=match.arg(type)
if(is.null(type)) type <- "lambda"
if(is.ts(x))
{
tsp.x <- tsp(x)
frq.x <- frequency(x)
if(type=="lambda")
{
if(is.null(freq))
{
if(frq.x==1)
lambda = 6
if(frq.x==4)
lambda = 1600
if(frq.x==12)
lambda = 129600
}
else
lambda = freq
}
}
else
{
if(type=="lambda")
{
if(is.null(freq))
stop("freq is NULL")
else
lambda = freq
}
}
if(type=="frequency")
{
if(is.null(freq))
stop("freq is NULL")
else
lambda = (2*sin(pi/freq))^-4
}
xo = x
x = as.matrix(x)
if(drift)
x = undrift(x)
n = length(x)
imat = diag(n)
Ln = rbind(matrix(0,1,n),diag(1,n-1,n))
Ln = (imat-Ln)%*%(imat-Ln)
Q  = t(Ln[3:n,])
SIGMA.R = t(Q)%*%Q
SIGMA.n = diag(n-2)
g = t(Q)%*%as.matrix(x)
b = solve(SIGMA.n+lambda*SIGMA.R,g)
x.cycle = c(lambda*Q%*%b)
x.trend = x-x.cycle
if(is.ts(xo))
{
tsp.x = tsp(xo)
x.cycle = ts(x.cycle, star=tsp.x[1], frequency=tsp.x[3])
x.trend = ts(x.trend, star=tsp.x[1], frequency=tsp.x[3])
x = ts(x,star=tsp.x[1], frequency = tsp.x[3])
}
A = lambda*Q%*%solve(SIGMA.n+lambda*SIGMA.R)%*%t(Q)
res <- list(cycle=x.cycle,trend=x.trend,fmatrix=A,title="Hodrick-Prescott Filter",
xname=xname,call=as.call(match.call()),
type=type,lambda=lambda,method="hpfilter",x=x)
return(structure(res,class="mFilter"))
}
# Funciones redefinidas en mFilter (Paquete)
## Generic mFilter functions
## Part of mFilter package
mFilter <- function(x, ...) UseMethod("mFilter")
mFilter.default <- function(x, ...) mFilter.ts(x, ...)
mFilter.ts <- function(x, filter=c("HP","BK","CF","BW","TR"), ...)
{
filt = match.arg(filter)
call = match.call()
ag = list(...)
switch(filt,
"HP" = {res <- hpfilter(x,freq=ag$freq,type=ag$type,drift=ag$drift)},
"BK" = {res <- bkfilter(x,pl=ag$pl,pu=ag$pu,nfix=ag$nfix,type=ag$type,drift=ag$drift)},
"CF" = {res <- cffilter(x,pl=ag$pl,pu=ag$pu,root=ag$root,drift=ag$drift,
type=ag$type, nfix=ag$nfix,theta=ag$theta)},
"BW" = {res <- bwfilter(x,freq=ag$freq,nfix=ag$nfix,drift=ag$drift)},
"TR" = {res <- trfilter(x,pl=ag$pl,pu=ag$pu,drift=ag$drift)}
)
res$xname <- deparse(substitute(x))
return(res)
}
print.mFilter <- function(x, digits = max(3, getOption("digits") - 3), ...)
{
if (!inherits(x, "mFilter"))
stop("method is only for mFilter objects")
# Title:
cat("\nTitle:\n ")
cat(x$title, "\n")
## Call:
cat("\nCall:\n ")
cat(paste(deparse(x$call), sep = "\n", collapse = "\n"),
"\n", sep = "")
## Method:
cat("\nMethod:\n ", x$method, "\n", sep = "")
## Filter Type:
cat("\nFilter Type:\n ", x$type, "\n", sep = "")
## Series
cat("\nSeries:\n ", x$xname, "\n\n", sep = "")
names <- c(x$xname,"Trend","Cycle")
out <- cbind(x$x,x$trend,x$cycle)
colnames(out) <- names
rownames(out) <- time(x$x)
if(any(frequency(x$x) == c(4,12)))
print(out, digits=digits)
else
print(as.data.frame(out),digits = digits)
invisible(x)
}
summary.mFilter <- function(object, digits = max(3, getOption("digits") - 3), ...)
{
if (!inherits(object, "mFilter"))
stop("method is only for mFilter objects")
## Title:
cat("\nTitle:\n ")
cat(object$title, "\n")
## Call:
cat("\nCall:\n ")
cat(paste(deparse(object$call), sep = "\n", collapse = "\n"),
"\n", sep = "")
## Method:
cat("\nMethod:\n ", object$method, "\n", sep = "")
## Filter Type:
cat("\nFilter Type:\n ", object$type, "\n", sep = "")
## Series
cat("\nSeries:\n ", object$xname, "\n", sep = "")
names <- c(object$xname,"Trend","Cycle")
out <- cbind(object$x,object$trend,object$cycle)
colnames(out) <- names
rownames(out) <- time(object$x)
cat("\nDescriptive Statistics:\n ", "\n", sep = "")
print(summary(out), digits = digits)
#browser()
gof <- function(object)
{
res <- object$cycle
pe <- res/object$x
out <- c(mean(res,na.rm=TRUE), mean(res^2,na.rm=TRUE),
mean(abs(res),na.rm=TRUE), mean(pe,na.rm=TRUE), mean(abs(pe),na.rm=TRUE))
names(out) <- c("ME","MSE","MAE","MPE","MAPE")
return(out)
}
cat("\nIn-sample error measures:\n")
print(gof(object), digits = digits)
cat("\n")
#if(any(frequency(object$x) == c(4,12)))
#print(out)
#else
#print(as.data.frame(out))
invisible(object)
}
plot.mFilter <- function(x, reference.grid = TRUE, col = "steelblue", ask=interactive(), ...)
{
if (!inherits(x, "mFilter"))
stop("method is only for mFilter objects")
opar <- par(no.readonly=TRUE)
par(ask=ask,mfrow=c(2,1),mar=c(3,2,2,1))
ag <- list(...)
if(is.null(ag$main))
main <- paste(x$title, "of", x$xname)
ylim <- range(c(x$x,x$trend),na.rm=TRUE)
plot(x$x,type="l",main=main,ylab="",ylim=ylim,col=col,...)
lines(x$trend,col="red")
if (reference.grid) grid()
legend("topleft",legend=c(x$xname,"trend"),col=c(col,"red"),lty=rep(1,2),ncol=2)
plot(x$cycle,type="l",main="Cyclical component (deviations from trend)",
ylab="",col=col,...)
if (reference.grid) grid()
par(opar)
invisible(x)
}
residuals.mFilter <- function(object, ...) return(object$cycle)
fitted.mFilter <- function(object, ...) return(object$trend)
plot(hpfilter(log(GDP),freq = 1600))
plot(hpfilter(BDDts[,1]))
plot(hpfilter(BDDts3[,1]))
plot(hpfilter(BDDts3[,2]))
plot(hpfilter(BDDts3[,3]))
plot(hpfilter(BDDts3[,4]))
plot(hpfilter(BDDts3[,5]))
plot(hpfilter(BDDts3[,6]))
install.packages("stlplus")
library(stlplus)
#Filtro Hodrick Prescott
hprx = hpfilter(BDDts3[,2])
library(stlplus)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 4,s.window = 5)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 4,s.window = 10)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 4,s.window = 12)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 8,s.window = 12)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 12)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 1)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 5)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 3)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 4)
plot(stlx)
plot(hprx)
plot(hprx,1)
plot(stlx$pars$)
plot(stlx$pars$deg)
plot(stlx$pars$win)
plot(stlx$pars$blend)
plot(stlx$pars$jump)
plot(stlx$pars$periodic)
plot(stlx$)
plot(stlx$fc)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 12)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 20)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 4)
plot(hprx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 12, t.window = 10)
plot(stlx)
#Filtro STL-Loess (Plus)
stlx = stlplus(BDDts3[,2],n.p= 12,s.window = 12, t.window = 1)
# library(mFilter)
library(quantmod)
library(stlplus)
source(file = "FiltroHodrickPrescott.R")
#Filtro Hodrick Prescott
hpGen = hpfilter(BDDts3[,1])
plot(hpGen)
hpProd = data.frame()
k = 1
for(i in 2:dim(BDDts3)[2]){
hpProd[,k] =  BDDts3[,i]/hpGen
k = k+1
}
hpGen$trend
for(i in 2:dim(BDDts3)[2]){
hpProd[,k] =  BDDts3[,i]/hpGen$trend
k = k+1
}
BDDts3[,i]/hpGen$trend
hpProd =  ts(NA, start = c(2005, 1),frequency = 12)
k = 1
for(i in 2:dim(BDDts3)[2]){
hpProd[,k] =  BDDts3[,i]/hpGen$trend
k = k+1
}
BDDts3[,i]/hpGen$trend
hpProd =  ts(NA, start = c(2005, 1), end = c(2018,5),frequency = 12)
k = 1
for(i in 2:dim(BDDts3)[2]){
hpProd[,k] =  BDDts3[,i]/hpGen$trend
k = k+1
}
install.packages("smooth")
install.packages("Mcomp")
library(Mcomp)
library(smooth)
help(install.packages)
install.packages("pracma")
.libPaths()
# Medias Moviles 5 (Centradas)   --------------------------
mav <- function(x,n=5){stats::filter(x,rep(1/n,n), sides=2)}
mav(BDDts3[,2],n=5)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){stats::filter(x,rep(1/n,n), sides=2)}
mvx = mav(BDDts3[,2],n=5)
plot(BDD)
plot(mvx)
plot(BDDts3[,2])
lines(mvx)
plot(BDDts3[,2])
lines(mvx, col="red")
mvx = mav(BDDts3[,2],n=9)
plot(BDDts3[,2])
lines(mvx, col="red")
BDDts3[,2] - mvx
resx = BDDts3[,2] - mvx
plot(resx)
par(mfrow=c(2,1))
plot(BDDts3[,2])
lines(mvx , col="red")
resx = BDDts3[,2] - mvx
plot(resx)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x)
lines(mvx , col="red")
plot(resx)
return(data.frame(x,mvx))
}
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x)
lines(mvx , col="red")
plot(resx)
return(data.frame(x,mvx))
}
mav(BDDts3[,2])
mav(BDDts3[,2], n =12)
mav(BDDts3[,2], n =12)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie")
lines(mvx , col="red",xlab="Residuos")
plot(resx)
return(data.frame(x,mvx))
}
mav(BDDts3[,2], n =12)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie")
lines(mvx , col="red")
plot(resx)
return(data.frame(x,mvx),ylab="Residuos")
}
mav(BDDts3[,2], n =12)
mav(BDDts3[,2], n =24)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie")
lines(mvx , col="red",main="Residuos")
plot(resx)
return(data.frame(x,mvx),ylab="Residuos")
}
mav(BDDts3[,2], n =24)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie")
lines(mvx , col="red",main="Residuos")
plot(resx,ylab="Residuos")
return(data.frame(x,mvx))
}
mav(BDDts3[,2], n =24)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie")
lines(mvx , col="red")
plot(resx,ylab="Residuos",main="Residuos")
return(data.frame(x,mvx))
}
mav(BDDts3[,2], n =24)
# Medias Moviles 5 (Centradas)   --------------------------
mav = function(x,n=5){
mvx = stats::filter(x,rep(1/n,n), sides=2)
resx = x - mvx
par(mfrow=c(2,1))
plot(x, main="Serie de Tiempo")
lines(mvx , col="red")
plot(resx,ylab="Residuos",main="Residuos")
return(data.frame(x,mvx))
}
mav(BDDts3[,2], n =24)
